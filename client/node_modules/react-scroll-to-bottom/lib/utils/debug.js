"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = debug;

var _styleConsole = _interopRequireDefault(require("./styleConsole"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function format(category, arg0) {
  for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    args[_key - 2] = arguments[_key];
  }

  return ["%c".concat(category, "%c ").concat(arg0)].concat(_toConsumableArray((0, _styleConsole.default)('green', 'white')), args);
}

function debug(category) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      _ref$force = _ref.force,
      force = _ref$force === void 0 ? false : _ref$force;

  if (!force) {
    return function () {
      return 0;
    };
  }

  return function () {
    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
      args[_key2] = arguments[_key2];
    }

    if (!args.length) {
      return;
    }

    var _args = args,
        _args2 = _slicedToArray(_args, 1),
        arg0 = _args2[0];

    if (typeof arg0 === 'function') {
      args = arg0();
    }

    var lines = Array.isArray(args[0]) ? args : [args];
    var oneLiner = lines.length === 1;
    lines.forEach(function (line, index) {
      if (oneLiner) {
        var _console;

        (_console = console).log.apply(_console, _toConsumableArray(format.apply(void 0, [category].concat(_toConsumableArray(line)))));
      } else if (index) {
        var _console2;

        (_console2 = console).log.apply(_console2, _toConsumableArray(Array.isArray(line) ? line : [line]));
      } else {
        var _console3;

        (_console3 = console).groupCollapsed.apply(_console3, _toConsumableArray(format.apply(void 0, [category].concat(_toConsumableArray(line)))));
      }
    });
    oneLiner || console.groupEnd();
  };
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy91dGlscy9kZWJ1Zy5qcyJdLCJuYW1lcyI6WyJmb3JtYXQiLCJjYXRlZ29yeSIsImFyZzAiLCJhcmdzIiwiZGVidWciLCJmb3JjZSIsImxlbmd0aCIsImxpbmVzIiwiQXJyYXkiLCJpc0FycmF5Iiwib25lTGluZXIiLCJmb3JFYWNoIiwibGluZSIsImluZGV4IiwiY29uc29sZSIsImxvZyIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFFQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBRUEsU0FBU0EsTUFBVCxDQUFnQkMsUUFBaEIsRUFBMEJDLElBQTFCLEVBQXlDO0FBQUEsb0NBQU5DLElBQU07QUFBTkEsSUFBQUEsSUFBTTtBQUFBOztBQUN2QyxzQkFBYUYsUUFBYixnQkFBMkJDLElBQTNCLDZCQUFzQywyQkFBYSxPQUFiLEVBQXNCLE9BQXRCLENBQXRDLEdBQXlFQyxJQUF6RTtBQUNEOztBQUVjLFNBQVNDLEtBQVQsQ0FBZUgsUUFBZixFQUFpRDtBQUFBLGlGQUFKLEVBQUk7QUFBQSx3QkFBdEJJLEtBQXNCO0FBQUEsTUFBdEJBLEtBQXNCLDJCQUFkLEtBQWM7O0FBQzlELE1BQUksQ0FBQ0EsS0FBTCxFQUFZO0FBQ1YsV0FBTztBQUFBLGFBQU0sQ0FBTjtBQUFBLEtBQVA7QUFDRDs7QUFFRCxTQUFPLFlBQWE7QUFBQSx1Q0FBVEYsSUFBUztBQUFUQSxNQUFBQSxJQUFTO0FBQUE7O0FBQ2xCLFFBQUksQ0FBQ0EsSUFBSSxDQUFDRyxNQUFWLEVBQWtCO0FBQ2hCO0FBQ0Q7O0FBSGlCLGdCQUtISCxJQUxHO0FBQUE7QUFBQSxRQUtYRCxJQUxXOztBQU9sQixRQUFJLE9BQU9BLElBQVAsS0FBZ0IsVUFBcEIsRUFBZ0M7QUFDOUJDLE1BQUFBLElBQUksR0FBR0QsSUFBSSxFQUFYO0FBQ0Q7O0FBRUQsUUFBTUssS0FBSyxHQUFHQyxLQUFLLENBQUNDLE9BQU4sQ0FBY04sSUFBSSxDQUFDLENBQUQsQ0FBbEIsSUFBeUJBLElBQXpCLEdBQWdDLENBQUNBLElBQUQsQ0FBOUM7QUFDQSxRQUFNTyxRQUFRLEdBQUdILEtBQUssQ0FBQ0QsTUFBTixLQUFpQixDQUFsQztBQUVBQyxJQUFBQSxLQUFLLENBQUNJLE9BQU4sQ0FBYyxVQUFDQyxJQUFELEVBQU9DLEtBQVAsRUFBaUI7QUFDN0IsVUFBSUgsUUFBSixFQUFjO0FBQUE7O0FBQ1osb0JBQUFJLE9BQU8sRUFBQ0MsR0FBUixvQ0FBZWYsTUFBTSxNQUFOLFVBQU9DLFFBQVAsNEJBQW9CVyxJQUFwQixHQUFmO0FBQ0QsT0FGRCxNQUVPLElBQUlDLEtBQUosRUFBVztBQUFBOztBQUNoQixxQkFBQUMsT0FBTyxFQUFDQyxHQUFSLHFDQUFnQlAsS0FBSyxDQUFDQyxPQUFOLENBQWNHLElBQWQsSUFBc0JBLElBQXRCLEdBQTZCLENBQUNBLElBQUQsQ0FBN0M7QUFDRCxPQUZNLE1BRUE7QUFBQTs7QUFDTCxxQkFBQUUsT0FBTyxFQUFDRSxjQUFSLHFDQUEwQmhCLE1BQU0sTUFBTixVQUFPQyxRQUFQLDRCQUFvQlcsSUFBcEIsR0FBMUI7QUFDRDtBQUNGLEtBUkQ7QUFVQUYsSUFBQUEsUUFBUSxJQUFJSSxPQUFPLENBQUNHLFFBQVIsRUFBWjtBQUNELEdBekJEO0FBMEJEIiwic291cmNlc0NvbnRlbnQiOlsiLyogZXNsaW50IG5vLWNvbnNvbGU6IFtcIm9mZlwiXSAqL1xuXG5pbXBvcnQgc3R5bGVDb25zb2xlIGZyb20gJy4vc3R5bGVDb25zb2xlJztcblxuZnVuY3Rpb24gZm9ybWF0KGNhdGVnb3J5LCBhcmcwLCAuLi5hcmdzKSB7XG4gIHJldHVybiBbYCVjJHtjYXRlZ29yeX0lYyAke2FyZzB9YCwgLi4uc3R5bGVDb25zb2xlKCdncmVlbicsICd3aGl0ZScpLCAuLi5hcmdzXTtcbn1cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gZGVidWcoY2F0ZWdvcnksIHsgZm9yY2UgPSBmYWxzZSB9ID0ge30pIHtcbiAgaWYgKCFmb3JjZSkge1xuICAgIHJldHVybiAoKSA9PiAwO1xuICB9XG5cbiAgcmV0dXJuICguLi5hcmdzKSA9PiB7XG4gICAgaWYgKCFhcmdzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IFthcmcwXSA9IGFyZ3M7XG5cbiAgICBpZiAodHlwZW9mIGFyZzAgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGFyZ3MgPSBhcmcwKCk7XG4gICAgfVxuXG4gICAgY29uc3QgbGluZXMgPSBBcnJheS5pc0FycmF5KGFyZ3NbMF0pID8gYXJncyA6IFthcmdzXTtcbiAgICBjb25zdCBvbmVMaW5lciA9IGxpbmVzLmxlbmd0aCA9PT0gMTtcblxuICAgIGxpbmVzLmZvckVhY2goKGxpbmUsIGluZGV4KSA9PiB7XG4gICAgICBpZiAob25lTGluZXIpIHtcbiAgICAgICAgY29uc29sZS5sb2coLi4uZm9ybWF0KGNhdGVnb3J5LCAuLi5saW5lKSk7XG4gICAgICB9IGVsc2UgaWYgKGluZGV4KSB7XG4gICAgICAgIGNvbnNvbGUubG9nKC4uLihBcnJheS5pc0FycmF5KGxpbmUpID8gbGluZSA6IFtsaW5lXSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc29sZS5ncm91cENvbGxhcHNlZCguLi5mb3JtYXQoY2F0ZWdvcnksIC4uLmxpbmUpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIG9uZUxpbmVyIHx8IGNvbnNvbGUuZ3JvdXBFbmQoKTtcbiAgfTtcbn1cbiJdfQ==