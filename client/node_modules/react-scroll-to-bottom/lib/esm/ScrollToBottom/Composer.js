function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }

function _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _iterableToArray(iter) { if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter); }

function _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }

function _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }

function _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function _iterableToArrayLimit(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

import createEmotion from 'create-emotion';
import PropTypes from 'prop-types';
import React, { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import createCSSKey from '../createCSSKey';
import createDebug from '../utils/debug';
import EventSpy from '../EventSpy';
import FunctionContext from './FunctionContext';
import InternalContext from './InternalContext';
import SpineTo from '../SpineTo';
import State1Context from './State1Context';
import State2Context from './State2Context';
import StateContext from './StateContext';
import styleConsole from '../utils/styleConsole';
import useStateRef from '../hooks/internal/useStateRef';

var DEFAULT_SCROLLER = function DEFAULT_SCROLLER() {
  return Infinity;
};

var MIN_CHECK_INTERVAL = 17; // 1 frame

var MODE_BOTTOM = 'bottom';
var MODE_TOP = 'top';
var NEAR_END_THRESHOLD = 1;
var SCROLL_DECISION_DURATION = 34; // 2 frames
// We pool the emotion object by nonce.
// This is to make sure we don't generate too many unneeded <style> tags.

var emotionPool = {};

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight < NEAR_END_THRESHOLD;
  var atTop = scrollTop < NEAR_END_THRESHOLD;
  var atEnd = mode === MODE_TOP ? atTop : atBottom;
  var atStart = mode !== MODE_TOP ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: atStart,
    atTop: atTop
  };
}

function isEnd(animateTo, mode) {
  return animateTo === (mode === MODE_TOP ? 0 : '100%');
}

var Composer = function Composer(_ref2) {
  var checkInterval = _ref2.checkInterval,
      children = _ref2.children,
      debounce = _ref2.debounce,
      debugFromProp = _ref2.debug,
      initialScrollBehavior = _ref2.initialScrollBehavior,
      mode = _ref2.mode,
      nonce = _ref2.nonce,
      scroller = _ref2.scroller;
  var debug = useMemo(function () {
    return createDebug("<ScrollToBottom>", {
      force: debugFromProp
    });
  }, [debugFromProp]);
  mode = mode === MODE_TOP ? MODE_TOP : MODE_BOTTOM;
  var ignoreScrollEventBeforeRef = useRef(0);
  var initialScrollBehaviorRef = useRef(initialScrollBehavior);

  var _useStateRef = useStateRef(mode === MODE_TOP ? 0 : '100%'),
      _useStateRef2 = _slicedToArray(_useStateRef, 3),
      animateTo = _useStateRef2[0],
      setAnimateTo = _useStateRef2[1],
      animateToRef = _useStateRef2[2];

  var _useStateRef3 = useStateRef(null),
      _useStateRef4 = _slicedToArray(_useStateRef3, 3),
      target = _useStateRef4[0],
      setTarget = _useStateRef4[1],
      targetRef = _useStateRef4[2]; // Internal context


  var animateFromRef = useRef(0);
  var offsetHeightRef = useRef(0);
  var scrollHeightRef = useRef(0); // State context

  var _useState = useState(true),
      _useState2 = _slicedToArray(_useState, 2),
      atBottom = _useState2[0],
      setAtBottom = _useState2[1];

  var _useState3 = useState(true),
      _useState4 = _slicedToArray(_useState3, 2),
      atEnd = _useState4[0],
      setAtEnd = _useState4[1];

  var _useState5 = useState(true),
      _useState6 = _slicedToArray(_useState5, 2),
      atTop = _useState6[0],
      setAtTop = _useState6[1];

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      atStart = _useState8[0],
      setAtStart = _useState8[1];

  var _useStateRef5 = useStateRef(true),
      _useStateRef6 = _slicedToArray(_useStateRef5, 3),
      sticky = _useStateRef6[0],
      setSticky = _useStateRef6[1],
      stickyRef = _useStateRef6[2]; // High-rate state context


  var scrollPositionObserversRef = useRef([]);
  var observeScrollPosition = useCallback(function (fn) {
    var target = targetRef.current;
    scrollPositionObserversRef.current.push(fn);
    target && fn({
      scrollTop: target.scrollTop
    });
    return function () {
      var scrollPositionObservers = scrollPositionObserversRef.current;
      var index = scrollPositionObservers.indexOf(fn);
      ~index && scrollPositionObservers.splice(index, 1);
    };
  }, [scrollPositionObserversRef, targetRef]);
  var handleSpineToEnd = useCallback(function () {
    var animateTo = animateToRef.current;
    debug(function () {
      return ['%cSpineTo%c: %conEnd%c is fired.'].concat(_toConsumableArray(styleConsole('magenta')), _toConsumableArray(styleConsole('orange')), [{
        animateTo: animateTo
      }]);
    });
    ignoreScrollEventBeforeRef.current = Date.now(); // handleScrollEnd may end at a position which should lose stickiness.
    // In that case, we will need to set sticky to false to stop the interval check.
    // Test case:
    // 1. Add a scroller that always return 0
    // 2. Show a panel with mode === MODE_BOTTOM
    // 3. Programmatically scroll to 0 (set element.scrollTop = 0)
    // Expected: it should not repetitively call scrollTo(0)
    //           it should set stickiness to false

    isEnd(animateTo, mode) || setSticky(false);
    setAnimateTo(null);
  }, [animateToRef, debug, ignoreScrollEventBeforeRef, mode, setAnimateTo, setSticky]); // Function context

  var scrollTo = useCallback(function (nextAnimateTo) {
    var _ref3 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
        behavior = _ref3.behavior;

    var target = targetRef.current;

    if (typeof nextAnimateTo !== 'number' && nextAnimateTo !== '100%') {
      return console.warn('react-scroll-to-bottom: Arguments passed to scrollTo() must be either number or "100%".');
    } // If it is trying to scroll to a position which is not "atEnd", it should set sticky to false after scroll ended.


    debug(function () {
      return [["%cscrollTo%c: Will scroll to %c".concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), "%c")].concat(_toConsumableArray(styleConsole('lime', '')), _toConsumableArray(styleConsole('purple'))), {
        behavior: behavior,
        nextAnimateTo: nextAnimateTo,
        target: target
      }];
    });

    if (behavior === 'auto') {
      // Stop any existing animation
      handleSpineToEnd();

      if (target) {
        // Jump to the scroll position
        target.scrollTop = nextAnimateTo === '100%' ? target.scrollHeight - target.offsetHeight : nextAnimateTo;
      }
    } else {
      behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollTo". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
      setAnimateTo(nextAnimateTo);
    } // This is for handling a case. When calling scrollTo('100%', { behavior: 'auto' }) multiple times, it would lose stickiness.


    if (isEnd(nextAnimateTo, mode)) {
      debug(function () {
        return [["%cscrollTo%c: Scrolling to end, will set sticky to %ctrue%c."].concat(_toConsumableArray(styleConsole('lime', '')), _toConsumableArray(styleConsole('purple'))), [{
          mode: mode,
          nextAnimateTo: nextAnimateTo
        }]];
      });
      setSticky(true);
    }
  }, [debug, handleSpineToEnd, mode, setAnimateTo, setSticky, targetRef]);
  var scrollToBottom = useCallback(function () {
    var _ref4 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref4.behavior;

    debug(function () {
      return ['%cscrollToBottom%c: Called'].concat(_toConsumableArray(styleConsole('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToBottom". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo('100%', {
      behavior: behavior || 'smooth'
    });
  }, [debug, scrollTo]);
  var scrollToTop = useCallback(function () {
    var _ref5 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref5.behavior;

    debug(function () {
      return ['%cscrollToTop%c: Called'].concat(_toConsumableArray(styleConsole('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToTop". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    scrollTo(0, {
      behavior: behavior || 'smooth'
    });
  }, [debug, scrollTo]);
  var scrollToEnd = useCallback(function () {
    var _ref6 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref6.behavior;

    debug(function () {
      return ['%cscrollToEnd%c: Called'].concat(_toConsumableArray(styleConsole('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToEnd". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToTop(options) : scrollToBottom(options);
  }, [debug, mode, scrollToBottom, scrollToTop]);
  var scrollToStart = useCallback(function () {
    var _ref7 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
        behavior = _ref7.behavior;

    debug(function () {
      return ['%cscrollToStart%c: Called'].concat(_toConsumableArray(styleConsole('yellow', '')));
    });
    behavior !== 'smooth' && console.warn('react-scroll-to-bottom: Please set "behavior" when calling "scrollToStart". In future versions, the default behavior will be changed from smooth scrolling to discrete scrolling to align with HTML Standard.');
    var options = {
      behavior: behavior || 'smooth'
    };
    mode === MODE_TOP ? scrollToBottom(options) : scrollToTop(options);
  }, [debug, mode, scrollToBottom, scrollToTop]);
  var scrollToSticky = useCallback(function () {
    var target = targetRef.current;

    if (target) {
      if (initialScrollBehaviorRef.current === 'auto') {
        debug(function () {
          return ["%ctarget changed%c: Initial scroll"].concat(_toConsumableArray(styleConsole('blue')));
        });
        target.scrollTop = mode === MODE_TOP ? 0 : target.scrollHeight - target.offsetHeight;
        initialScrollBehaviorRef.current = false;
        return;
      } // This is very similar to scrollToEnd().
      // Instead of scrolling to end, it will call props.scroller() to determines how far it should scroll.
      // This function could be called while it is auto-scrolling.


      var animateFrom = animateFromRef.current;
      var offsetHeight = target.offsetHeight,
          scrollHeight = target.scrollHeight,
          scrollTop = target.scrollTop;
      var maxValue = mode === MODE_TOP ? 0 : Math.max(0, scrollHeight - offsetHeight - scrollTop);
      var minValue = Math.max(0, animateFrom - scrollTop);
      var rawNextValue = scroller({
        maxValue: maxValue,
        minValue: minValue,
        offsetHeight: offsetHeight,
        scrollHeight: scrollHeight,
        scrollTop: scrollTop
      });
      var nextValue = Math.max(0, Math.min(maxValue, rawNextValue));
      var nextAnimateTo;

      if (mode === MODE_TOP || nextValue !== maxValue) {
        nextAnimateTo = scrollTop + nextValue;
      } else {
        // When scrolling to bottom, we should scroll to "100%".
        // Otherwise, if we scroll to any number, it will lose stickiness when elements are adding too fast.
        // "100%" is a special argument intended to make sure stickiness is not lost while new elements are being added.
        nextAnimateTo = '100%';
      }

      debug(function () {
        return [["%cscrollToSticky%c: Will animate from %c".concat(animateFrom, "px%c to %c").concat(typeof nextAnimateTo === 'number' ? nextAnimateTo + 'px' : nextAnimateTo.replace(/%/g, '%%'), "%c (%c").concat((nextAnimateTo === '100%' ? maxValue : nextAnimateTo) + animateFrom, "px%c)")].concat(_toConsumableArray(styleConsole('orange')), _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple'))), {
          animateFrom: animateFrom,
          maxValue: maxValue,
          minValue: minValue,
          nextAnimateTo: nextAnimateTo,
          nextValue: nextValue,
          offsetHeight: offsetHeight,
          rawNextValue: rawNextValue,
          scrollHeight: scrollHeight,
          scrollTop: scrollTop
        }];
      });
      scrollTo(nextAnimateTo, {
        behavior: 'smooth'
      });
    }
  }, [animateFromRef, debug, mode, scroller, scrollTo, targetRef]);
  var handleScroll = useCallback(function (_ref8) {
    var timeStampLow = _ref8.timeStampLow;
    var animateTo = animateToRef.current;
    var target = targetRef.current;
    var animating = animateTo !== null; // Currently, there are no reliable way to check if the "scroll" event is trigger due to
    // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
    // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.

    if (timeStampLow <= ignoreScrollEventBeforeRef.current || !target) {
      // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
      // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
      // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
      return;
    }

    var _computeViewState = computeViewState({
      mode: mode,
      target: target
    }),
        atBottom = _computeViewState.atBottom,
        atEnd = _computeViewState.atEnd,
        atStart = _computeViewState.atStart,
        atTop = _computeViewState.atTop;

    setAtBottom(atBottom);
    setAtEnd(atEnd);
    setAtStart(atStart);
    setAtTop(atTop); // Chrome will emit "synthetic" scroll event if the container is resized or an element is added
    // We need to ignore these "synthetic" events
    // Repro: In playground, press 4-1-5-1-1 (small, add one, normal, add one, add one)
    //        Nomatter how fast or slow the sequence is being pressed, it should still stick to the bottom

    var nextOffsetHeight = target.offsetHeight,
        nextScrollHeight = target.scrollHeight;
    var offsetHeight = offsetHeightRef.current;
    var scrollHeight = scrollHeightRef.current;
    var offsetHeightChanged = nextOffsetHeight !== offsetHeight;
    var scrollHeightChanged = nextScrollHeight !== scrollHeight;

    if (offsetHeightChanged) {
      offsetHeightRef.current = nextOffsetHeight;
    }

    if (scrollHeightChanged) {
      scrollHeightRef.current = nextScrollHeight;
    } // Sticky means:
    // - If it is scrolled programatically, we are still in sticky mode
    // - If it is scrolled by the user, then sticky means if we are at the end
    // Only update stickiness if the scroll event is not due to synthetic scroll done by Chrome


    if (!offsetHeightChanged && !scrollHeightChanged) {
      // We are sticky if we are animating to the end, or we are already at the end.
      // We can be "animating but not sticky" by calling "scrollTo(100)" where the container scrollHeight is 200px.
      var nextSticky = animating && isEnd(animateTo, mode) || atEnd;

      if (stickyRef.current !== nextSticky) {
        debug(function () {
          return [["%conScroll%c: %csetSticky%c(%c".concat(nextSticky, "%c)")].concat(_toConsumableArray(styleConsole('red')), _toConsumableArray(styleConsole('red')), _toConsumableArray(styleConsole('purple'))), ["(animating = %c".concat(animating, "%c && isEnd = %c").concat(isEnd(animateTo, mode), "%c) || atEnd = %c").concat(atEnd, "%c")].concat(_toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple')), _toConsumableArray(styleConsole('purple')), [{
            animating: animating,
            animateTo: animateTo,
            atEnd: atEnd,
            mode: mode,
            offsetHeight: target.offsetHeight,
            scrollHeight: target.scrollHeight,
            sticky: sticky,
            nextSticky: nextSticky
          }])];
        });
        setSticky(nextSticky);
      }
    } else if (stickyRef.current) {
      debug(function () {
        return [["%conScroll%c: Size changed while sticky, calling %cscrollToSticky()%c"].concat(_toConsumableArray(styleConsole('red')), _toConsumableArray(styleConsole('orange')), [{
          offsetHeightChanged: offsetHeightChanged,
          scrollHeightChanged: scrollHeightChanged
        }]), {
          nextOffsetHeight: nextOffsetHeight,
          prevOffsetHeight: offsetHeight,
          nextScrollHeight: nextScrollHeight,
          prevScrollHeight: scrollHeight
        }];
      });
      scrollToSticky();
    }

    var actualScrollTop = target.scrollTop;
    scrollPositionObserversRef.current.forEach(function (observer) {
      return observer({
        scrollTop: actualScrollTop
      });
    });
  }, [animateToRef, debug, ignoreScrollEventBeforeRef, mode, offsetHeightRef, scrollHeightRef, scrollPositionObserversRef, scrollToSticky, setAtBottom, setAtEnd, setAtStart, setAtTop, setSticky, stickyRef, targetRef]);
  useEffect(function () {
    if (target) {
      var stickyButNotAtEndSince = false;
      var timeout = setImmediateInterval(function () {
        var target = targetRef.current;
        var animating = animateToRef.current !== null;

        if (stickyRef.current) {
          if (!computeViewState({
            mode: mode,
            target: target
          }).atEnd) {
            if (!stickyButNotAtEndSince) {
              stickyButNotAtEndSince = Date.now();
            } else if (Date.now() - stickyButNotAtEndSince > SCROLL_DECISION_DURATION) {
              // Quirks: In Firefox, after user scroll down, Firefox do two things:
              //         1. Set to a new "scrollTop"
              //         2. Fire "scroll" event
              //         For what we observed, #1 is fired about 20ms before #2. There is a chance that this stickyCheckTimeout is being scheduled between 1 and 2.
              //         That means, if we just look at #1 to decide if we should scroll, we will always scroll, in oppose to the user's intention.
              // Repro: Open Firefox, set checkInterval to a lower number, and try to scroll by dragging the scroll handler. It will jump back.
              // The "animating" check will make sure stickiness is not lost when elements are adding at a very fast pace.
              if (!animating) {
                animateFromRef.current = target.scrollTop;
                debug(function () {
                  return ["%cInterval check%c: Should sticky but not at end, calling %cscrollToSticky()%c to scroll"].concat(_toConsumableArray(styleConsole('navy')), _toConsumableArray(styleConsole('orange')));
                });
                scrollToSticky();
              }

              stickyButNotAtEndSince = false;
            }
          } else {
            stickyButNotAtEndSince = false;
          }
        } else if (target.scrollHeight <= target.offsetHeight && !stickyRef.current) {
          // When the container is emptied, we will set sticky back to true.
          debug(function () {
            return [["%cInterval check%c: Container is emptied, setting sticky back to %ctrue%c"].concat(_toConsumableArray(styleConsole('navy')), _toConsumableArray(styleConsole('purple'))), [{
              offsetHeight: target.offsetHeight,
              scrollHeight: target.scrollHeight,
              sticky: stickyRef.current
            }]];
          });
          setSticky(true);
        }
      }, Math.max(MIN_CHECK_INTERVAL, checkInterval) || MIN_CHECK_INTERVAL);
      return function () {
        return clearInterval(timeout);
      };
    }
  }, [animateToRef, checkInterval, debug, mode, scrollToSticky, setSticky, stickyRef, target, targetRef]);
  var styleToClassName = useMemo(function () {
    var emotion = emotionPool[nonce] || (emotionPool[nonce] = createEmotion({
      key: 'react-scroll-to-bottom--css-' + createCSSKey(),
      nonce: nonce
    }));
    return function (style) {
      return emotion.css(style) + '';
    };
  }, [nonce]);
  var internalContext = useMemo(function () {
    return {
      observeScrollPosition: observeScrollPosition,
      setTarget: setTarget,
      styleToClassName: styleToClassName
    };
  }, [observeScrollPosition, setTarget, styleToClassName]);
  var state1Context = useMemo(function () {
    return {
      atBottom: atBottom,
      atEnd: atEnd,
      atStart: atStart,
      atTop: atTop,
      mode: mode
    };
  }, [atBottom, atEnd, atStart, atTop, mode]);
  var state2Context = useMemo(function () {
    var animating = animateTo !== null;
    return {
      animating: animating,
      animatingToEnd: animating && isEnd(animateTo, mode),
      sticky: sticky
    };
  }, [animateTo, debug, mode, sticky]);
  var combinedStateContext = useMemo(function () {
    return _objectSpread(_objectSpread({}, state1Context), state2Context);
  }, [state1Context, state2Context]);
  var functionContext = useMemo(function () {
    return {
      scrollTo: scrollTo,
      scrollToBottom: scrollToBottom,
      scrollToEnd: scrollToEnd,
      scrollToStart: scrollToStart,
      scrollToTop: scrollToTop
    };
  }, [scrollTo, scrollToBottom, scrollToEnd, scrollToStart, scrollToTop]);
  useEffect(function () {
    // We need to update the "scrollHeight" value to latest when the user do a focus inside the box.
    //
    // This is because:
    // - In our code that mitigate Chrome synthetic scrolling, that code will look at whether "scrollHeight" value is latest or not.
    // - That code only run on "scroll" event.
    // - That means, on every "scroll" event, if the "scrollHeight" value is not latest, we will skip modifying the stickiness.
    // - That means, if the user "focus" to an element that cause the scroll view to scroll to the bottom, the user agent will fire "scroll" event.
    //   Since the "scrollHeight" is not latest value, this "scroll" event will be ignored and stickiness will not be modified.
    // - That means, if the user "focus" to a newly added element that is at the end of the scroll view, the "scroll to bottom" button will continue to show.
    //
    // Repro in Chrome:
    // 1. Fill up a scroll view
    // 2. Scroll up, the "scroll to bottom" button should show up
    // 3. Click "Add a button"
    // 4. Click on the scroll view (to pseudo-focus on it)
    // 5. Press TAB, the scroll view will be at the bottom
    //
    // Expect:
    // - The "scroll to bottom" button should be gone.
    if (target) {
      var handleFocus = function handleFocus() {
        scrollHeightRef.current = target.scrollHeight;
      };

      target.addEventListener('focus', handleFocus, {
        capture: true,
        passive: true
      });
      return function () {
        return target.removeEventListener('focus', handleFocus);
      };
    }
  }, [target]);
  debug(function () {
    return [["%cRender%c: Render"].concat(_toConsumableArray(styleConsole('cyan', ''))), {
      animateTo: animateTo,
      animating: animateTo !== null,
      sticky: sticky,
      target: target
    }];
  });
  return /*#__PURE__*/React.createElement(InternalContext.Provider, {
    value: internalContext
  }, /*#__PURE__*/React.createElement(FunctionContext.Provider, {
    value: functionContext
  }, /*#__PURE__*/React.createElement(StateContext.Provider, {
    value: combinedStateContext
  }, /*#__PURE__*/React.createElement(State1Context.Provider, {
    value: state1Context
  }, /*#__PURE__*/React.createElement(State2Context.Provider, {
    value: state2Context
  }, children, target && /*#__PURE__*/React.createElement(EventSpy, {
    debounce: debounce,
    name: "scroll",
    onEvent: handleScroll,
    target: target
  }), target && animateTo !== null && /*#__PURE__*/React.createElement(SpineTo, {
    name: "scrollTop",
    onEnd: handleSpineToEnd,
    target: target,
    value: animateTo
  }))))));
};

Composer.defaultProps = {
  checkInterval: 100,
  children: undefined,
  debounce: 17,
  debug: undefined,
  initialScrollBehavior: 'smooth',
  mode: undefined,
  nonce: undefined,
  scroller: DEFAULT_SCROLLER
};
Composer.propTypes = {
  checkInterval: PropTypes.number,
  children: PropTypes.any,
  debounce: PropTypes.number,
  debug: PropTypes.bool,
  initialScrollBehavior: PropTypes.oneOf(['auto', 'smooth']),
  mode: PropTypes.oneOf(['bottom', 'top']),
  nonce: PropTypes.string,
  scroller: PropTypes.func
};
export default Composer;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJjcmVhdGVFbW90aW9uIiwiUHJvcFR5cGVzIiwiUmVhY3QiLCJ1c2VDYWxsYmFjayIsInVzZUVmZmVjdCIsInVzZU1lbW8iLCJ1c2VSZWYiLCJ1c2VTdGF0ZSIsImNyZWF0ZUNTU0tleSIsImNyZWF0ZURlYnVnIiwiRXZlbnRTcHkiLCJGdW5jdGlvbkNvbnRleHQiLCJJbnRlcm5hbENvbnRleHQiLCJTcGluZVRvIiwiU3RhdGUxQ29udGV4dCIsIlN0YXRlMkNvbnRleHQiLCJTdGF0ZUNvbnRleHQiLCJzdHlsZUNvbnNvbGUiLCJ1c2VTdGF0ZVJlZiIsIkRFRkFVTFRfU0NST0xMRVIiLCJJbmZpbml0eSIsIk1JTl9DSEVDS19JTlRFUlZBTCIsIk1PREVfQk9UVE9NIiwiTU9ERV9UT1AiLCJORUFSX0VORF9USFJFU0hPTEQiLCJTQ1JPTExfREVDSVNJT05fRFVSQVRJT04iLCJlbW90aW9uUG9vbCIsInNldEltbWVkaWF0ZUludGVydmFsIiwiZm4iLCJtcyIsInNldEludGVydmFsIiwiY29tcHV0ZVZpZXdTdGF0ZSIsIm1vZGUiLCJ0YXJnZXQiLCJvZmZzZXRIZWlnaHQiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxUb3AiLCJhdEJvdHRvbSIsImF0VG9wIiwiYXRFbmQiLCJhdFN0YXJ0IiwiaXNFbmQiLCJhbmltYXRlVG8iLCJDb21wb3NlciIsImNoZWNrSW50ZXJ2YWwiLCJjaGlsZHJlbiIsImRlYm91bmNlIiwiZGVidWdGcm9tUHJvcCIsImRlYnVnIiwiaW5pdGlhbFNjcm9sbEJlaGF2aW9yIiwibm9uY2UiLCJzY3JvbGxlciIsImZvcmNlIiwiaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYiLCJpbml0aWFsU2Nyb2xsQmVoYXZpb3JSZWYiLCJzZXRBbmltYXRlVG8iLCJhbmltYXRlVG9SZWYiLCJzZXRUYXJnZXQiLCJ0YXJnZXRSZWYiLCJhbmltYXRlRnJvbVJlZiIsIm9mZnNldEhlaWdodFJlZiIsInNjcm9sbEhlaWdodFJlZiIsInNldEF0Qm90dG9tIiwic2V0QXRFbmQiLCJzZXRBdFRvcCIsInNldEF0U3RhcnQiLCJzdGlja3kiLCJzZXRTdGlja3kiLCJzdGlja3lSZWYiLCJzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZiIsIm9ic2VydmVTY3JvbGxQb3NpdGlvbiIsImN1cnJlbnQiLCJwdXNoIiwic2Nyb2xsUG9zaXRpb25PYnNlcnZlcnMiLCJpbmRleCIsImluZGV4T2YiLCJzcGxpY2UiLCJoYW5kbGVTcGluZVRvRW5kIiwiRGF0ZSIsIm5vdyIsInNjcm9sbFRvIiwibmV4dEFuaW1hdGVUbyIsImJlaGF2aW9yIiwiY29uc29sZSIsIndhcm4iLCJyZXBsYWNlIiwic2Nyb2xsVG9Cb3R0b20iLCJzY3JvbGxUb1RvcCIsInNjcm9sbFRvRW5kIiwib3B0aW9ucyIsInNjcm9sbFRvU3RhcnQiLCJzY3JvbGxUb1N0aWNreSIsImFuaW1hdGVGcm9tIiwibWF4VmFsdWUiLCJNYXRoIiwibWF4IiwibWluVmFsdWUiLCJyYXdOZXh0VmFsdWUiLCJuZXh0VmFsdWUiLCJtaW4iLCJoYW5kbGVTY3JvbGwiLCJ0aW1lU3RhbXBMb3ciLCJhbmltYXRpbmciLCJuZXh0T2Zmc2V0SGVpZ2h0IiwibmV4dFNjcm9sbEhlaWdodCIsIm9mZnNldEhlaWdodENoYW5nZWQiLCJzY3JvbGxIZWlnaHRDaGFuZ2VkIiwibmV4dFN0aWNreSIsInByZXZPZmZzZXRIZWlnaHQiLCJwcmV2U2Nyb2xsSGVpZ2h0IiwiYWN0dWFsU2Nyb2xsVG9wIiwiZm9yRWFjaCIsIm9ic2VydmVyIiwic3RpY2t5QnV0Tm90QXRFbmRTaW5jZSIsInRpbWVvdXQiLCJjbGVhckludGVydmFsIiwic3R5bGVUb0NsYXNzTmFtZSIsImVtb3Rpb24iLCJrZXkiLCJzdHlsZSIsImNzcyIsImludGVybmFsQ29udGV4dCIsInN0YXRlMUNvbnRleHQiLCJzdGF0ZTJDb250ZXh0IiwiYW5pbWF0aW5nVG9FbmQiLCJjb21iaW5lZFN0YXRlQ29udGV4dCIsImZ1bmN0aW9uQ29udGV4dCIsImhhbmRsZUZvY3VzIiwiYWRkRXZlbnRMaXN0ZW5lciIsImNhcHR1cmUiLCJwYXNzaXZlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImRlZmF1bHRQcm9wcyIsInVuZGVmaW5lZCIsInByb3BUeXBlcyIsIm51bWJlciIsImFueSIsImJvb2wiLCJvbmVPZiIsInN0cmluZyIsImZ1bmMiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEsT0FBT0EsYUFBUCxNQUEwQixnQkFBMUI7QUFDQSxPQUFPQyxTQUFQLE1BQXNCLFlBQXRCO0FBQ0EsT0FBT0MsS0FBUCxJQUFnQkMsV0FBaEIsRUFBNkJDLFNBQTdCLEVBQXdDQyxPQUF4QyxFQUFpREMsTUFBakQsRUFBeURDLFFBQXpELFFBQXlFLE9BQXpFO0FBRUEsT0FBT0MsWUFBUCxNQUF5QixpQkFBekI7QUFDQSxPQUFPQyxXQUFQLE1BQXdCLGdCQUF4QjtBQUNBLE9BQU9DLFFBQVAsTUFBcUIsYUFBckI7QUFDQSxPQUFPQyxlQUFQLE1BQTRCLG1CQUE1QjtBQUNBLE9BQU9DLGVBQVAsTUFBNEIsbUJBQTVCO0FBQ0EsT0FBT0MsT0FBUCxNQUFvQixZQUFwQjtBQUNBLE9BQU9DLGFBQVAsTUFBMEIsaUJBQTFCO0FBQ0EsT0FBT0MsYUFBUCxNQUEwQixpQkFBMUI7QUFDQSxPQUFPQyxZQUFQLE1BQXlCLGdCQUF6QjtBQUNBLE9BQU9DLFlBQVAsTUFBeUIsdUJBQXpCO0FBQ0EsT0FBT0MsV0FBUCxNQUF3QiwrQkFBeEI7O0FBRUEsSUFBTUMsZ0JBQWdCLEdBQUcsU0FBbkJBLGdCQUFtQjtBQUFBLFNBQU1DLFFBQU47QUFBQSxDQUF6Qjs7QUFDQSxJQUFNQyxrQkFBa0IsR0FBRyxFQUEzQixDLENBQStCOztBQUMvQixJQUFNQyxXQUFXLEdBQUcsUUFBcEI7QUFDQSxJQUFNQyxRQUFRLEdBQUcsS0FBakI7QUFDQSxJQUFNQyxrQkFBa0IsR0FBRyxDQUEzQjtBQUNBLElBQU1DLHdCQUF3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LE1BQUQsRUFBUyxRQUFULENBQWhCLENBTEo7QUFNbkIxRyxFQUFBQSxJQUFJLEVBQUUvQixTQUFTLENBQUN5SSxLQUFWLENBQWdCLENBQUMsUUFBRCxFQUFXLEtBQVgsQ0FBaEIsQ0FOYTtBQU9uQnhGLEVBQUFBLEtBQUssRUFBRWpELFNBQVMsQ0FBQzBJLE1BUEU7QUFRbkJ4RixFQUFBQSxRQUFRLEVBQUVsRCxTQUFTLENBQUMySTtBQVJELENBQXJCO0FBV0EsZUFBZWpHLFFBQWYiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgY3JlYXRlRW1vdGlvbiBmcm9tICdjcmVhdGUtZW1vdGlvbic7XG5pbXBvcnQgUHJvcFR5cGVzIGZyb20gJ3Byb3AtdHlwZXMnO1xuaW1wb3J0IFJlYWN0LCB7IHVzZUNhbGxiYWNrLCB1c2VFZmZlY3QsIHVzZU1lbW8sIHVzZVJlZiwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5cbmltcG9ydCBjcmVhdGVDU1NLZXkgZnJvbSAnLi4vY3JlYXRlQ1NTS2V5JztcbmltcG9ydCBjcmVhdGVEZWJ1ZyBmcm9tICcuLi91dGlscy9kZWJ1Zyc7XG5pbXBvcnQgRXZlbnRTcHkgZnJvbSAnLi4vRXZlbnRTcHknO1xuaW1wb3J0IEZ1bmN0aW9uQ29udGV4dCBmcm9tICcuL0Z1bmN0aW9uQ29udGV4dCc7XG5pbXBvcnQgSW50ZXJuYWxDb250ZXh0IGZyb20gJy4vSW50ZXJuYWxDb250ZXh0JztcbmltcG9ydCBTcGluZVRvIGZyb20gJy4uL1NwaW5lVG8nO1xuaW1wb3J0IFN0YXRlMUNvbnRleHQgZnJvbSAnLi9TdGF0ZTFDb250ZXh0JztcbmltcG9ydCBTdGF0ZTJDb250ZXh0IGZyb20gJy4vU3RhdGUyQ29udGV4dCc7XG5pbXBvcnQgU3RhdGVDb250ZXh0IGZyb20gJy4vU3RhdGVDb250ZXh0JztcbmltcG9ydCBzdHlsZUNvbnNvbGUgZnJvbSAnLi4vdXRpbHMvc3R5bGVDb25zb2xlJztcbmltcG9ydCB1c2VTdGF0ZVJlZiBmcm9tICcuLi9ob29rcy9pbnRlcm5hbC91c2VTdGF0ZVJlZic7XG5cbmNvbnN0IERFRkFVTFRfU0NST0xMRVIgPSAoKSA9PiBJbmZpbml0eTtcbmNvbnN0IE1JTl9DSEVDS19JTlRFUlZBTCA9IDE3OyAvLyAxIGZyYW1lXG5jb25zdCBNT0RFX0JPVFRPTSA9ICdib3R0b20nO1xuY29uc3QgTU9ERV9UT1AgPSAndG9wJztcbmNvbnN0IE5FQVJfRU5EX1RIUkVTSE9MRCA9IDE7XG5jb25zdCBTQ1JPTExfREVDSVNJT05fRFVSQVRJT04gPSAzNDsgLy8gMiBmcmFtZXNcblxuLy8gV2UgcG9vbCB0aGUgZW1vdGlvbiBvYmplY3QgYnkgbm9uY2UuXG4vLyBUaGlzIGlzIHRvIG1ha2Ugc3VyZSB3ZSBkb24ndCBnZW5lcmF0ZSB0b28gbWFueSB1bm5lZWRlZCA8c3R5bGU+IHRhZ3MuXG5jb25zdCBlbW90aW9uUG9vbCA9IHt9O1xuXG5mdW5jdGlvbiBzZXRJbW1lZGlhdGVJbnRlcnZhbChmbiwgbXMpIHtcbiAgZm4oKTtcblxuICByZXR1cm4gc2V0SW50ZXJ2YWwoZm4sIG1zKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldDogeyBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gfSkge1xuICBjb25zdCBhdEJvdHRvbSA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCAtIG9mZnNldEhlaWdodCA8IE5FQVJfRU5EX1RIUkVTSE9MRDtcbiAgY29uc3QgYXRUb3AgPSBzY3JvbGxUb3AgPCBORUFSX0VORF9USFJFU0hPTEQ7XG5cbiAgY29uc3QgYXRFbmQgPSBtb2RlID09PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG4gIGNvbnN0IGF0U3RhcnQgPSBtb2RlICE9PSBNT0RFX1RPUCA/IGF0VG9wIDogYXRCb3R0b207XG5cbiAgcmV0dXJuIHtcbiAgICBhdEJvdHRvbSxcbiAgICBhdEVuZCxcbiAgICBhdFN0YXJ0LFxuICAgIGF0VG9wXG4gIH07XG59XG5cbmZ1bmN0aW9uIGlzRW5kKGFuaW1hdGVUbywgbW9kZSkge1xuICByZXR1cm4gYW5pbWF0ZVRvID09PSAobW9kZSA9PT0gTU9ERV9UT1AgPyAwIDogJzEwMCUnKTtcbn1cblxuY29uc3QgQ29tcG9zZXIgPSAoe1xuICBjaGVja0ludGVydmFsLFxuICBjaGlsZHJlbixcbiAgZGVib3VuY2UsXG4gIGRlYnVnOiBkZWJ1Z0Zyb21Qcm9wLFxuICBpbml0aWFsU2Nyb2xsQmVoYXZpb3IsXG4gIG1vZGUsXG4gIG5vbmNlLFxuICBzY3JvbGxlclxufSkgPT4ge1xuICBjb25zdCBkZWJ1ZyA9IHVzZU1lbW8oKCkgPT4gY3JlYXRlRGVidWcoYDxTY3JvbGxUb0JvdHRvbT5gLCB7IGZvcmNlOiBkZWJ1Z0Zyb21Qcm9wIH0pLCBbZGVidWdGcm9tUHJvcF0pO1xuXG4gIG1vZGUgPSBtb2RlID09PSBNT0RFX1RPUCA/IE1PREVfVE9QIDogTU9ERV9CT1RUT007XG5cbiAgY29uc3QgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IGluaXRpYWxTY3JvbGxCZWhhdmlvclJlZiA9IHVzZVJlZihpbml0aWFsU2Nyb2xsQmVoYXZpb3IpO1xuICBjb25zdCBbYW5pbWF0ZVRvLCBzZXRBbmltYXRlVG8sIGFuaW1hdGVUb1JlZl0gPSB1c2VTdGF0ZVJlZihtb2RlID09PSBNT0RFX1RPUCA/IDAgOiAnMTAwJScpO1xuICBjb25zdCBbdGFyZ2V0LCBzZXRUYXJnZXQsIHRhcmdldFJlZl0gPSB1c2VTdGF0ZVJlZihudWxsKTtcblxuICAvLyBJbnRlcm5hbCBjb250ZXh0XG4gIGNvbnN0IGFuaW1hdGVGcm9tUmVmID0gdXNlUmVmKDApO1xuICBjb25zdCBvZmZzZXRIZWlnaHRSZWYgPSB1c2VSZWYoMCk7XG4gIGNvbnN0IHNjcm9sbEhlaWdodFJlZiA9IHVzZVJlZigwKTtcblxuICAvLyBTdGF0ZSBjb250ZXh0XG4gIGNvbnN0IFthdEJvdHRvbSwgc2V0QXRCb3R0b21dID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdEVuZCwgc2V0QXRFbmRdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdFRvcCwgc2V0QXRUb3BdID0gdXNlU3RhdGUodHJ1ZSk7XG4gIGNvbnN0IFthdFN0YXJ0LCBzZXRBdFN0YXJ0XSA9IHVzZVN0YXRlKGZhbHNlKTtcbiAgY29uc3QgW3N0aWNreSwgc2V0U3RpY2t5LCBzdGlja3lSZWZdID0gdXNlU3RhdGVSZWYodHJ1ZSk7XG5cbiAgLy8gSGlnaC1yYXRlIHN0YXRlIGNvbnRleHRcbiAgY29uc3Qgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYgPSB1c2VSZWYoW10pO1xuICBjb25zdCBvYnNlcnZlU2Nyb2xsUG9zaXRpb24gPSB1c2VDYWxsYmFjayhcbiAgICBmbiA9PiB7XG4gICAgICBjb25zdCB7IGN1cnJlbnQ6IHRhcmdldCB9ID0gdGFyZ2V0UmVmO1xuXG4gICAgICBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZi5jdXJyZW50LnB1c2goZm4pO1xuICAgICAgdGFyZ2V0ICYmIGZuKHsgc2Nyb2xsVG9wOiB0YXJnZXQuc2Nyb2xsVG9wIH0pO1xuXG4gICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICBjb25zdCB7IGN1cnJlbnQ6IHNjcm9sbFBvc2l0aW9uT2JzZXJ2ZXJzIH0gPSBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZjtcbiAgICAgICAgY29uc3QgaW5kZXggPSBzY3JvbGxQb3NpdGlvbk9ic2VydmVycy5pbmRleE9mKGZuKTtcblxuICAgICAgICB+aW5kZXggJiYgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnMuc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBbc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYsIHRhcmdldFJlZl1cbiAgKTtcblxuICBjb25zdCBoYW5kbGVTcGluZVRvRW5kID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudDogYW5pbWF0ZVRvIH0gPSBhbmltYXRlVG9SZWY7XG5cbiAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAnJWNTcGluZVRvJWM6ICVjb25FbmQlYyBpcyBmaXJlZC4nLFxuICAgICAgLi4uc3R5bGVDb25zb2xlKCdtYWdlbnRhJyksXG4gICAgICAuLi5zdHlsZUNvbnNvbGUoJ29yYW5nZScpLFxuICAgICAgeyBhbmltYXRlVG8gfVxuICAgIF0pO1xuXG4gICAgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYuY3VycmVudCA9IERhdGUubm93KCk7XG5cbiAgICAvLyBoYW5kbGVTY3JvbGxFbmQgbWF5IGVuZCBhdCBhIHBvc2l0aW9uIHdoaWNoIHNob3VsZCBsb3NlIHN0aWNraW5lc3MuXG4gICAgLy8gSW4gdGhhdCBjYXNlLCB3ZSB3aWxsIG5lZWQgdG8gc2V0IHN0aWNreSB0byBmYWxzZSB0byBzdG9wIHRoZSBpbnRlcnZhbCBjaGVjay5cbiAgICAvLyBUZXN0IGNhc2U6XG4gICAgLy8gMS4gQWRkIGEgc2Nyb2xsZXIgdGhhdCBhbHdheXMgcmV0dXJuIDBcbiAgICAvLyAyLiBTaG93IGEgcGFuZWwgd2l0aCBtb2RlID09PSBNT0RFX0JPVFRPTVxuICAgIC8vIDMuIFByb2dyYW1tYXRpY2FsbHkgc2Nyb2xsIHRvIDAgKHNldCBlbGVtZW50LnNjcm9sbFRvcCA9IDApXG4gICAgLy8gRXhwZWN0ZWQ6IGl0IHNob3VsZCBub3QgcmVwZXRpdGl2ZWx5IGNhbGwgc2Nyb2xsVG8oMClcbiAgICAvLyAgICAgICAgICAgaXQgc2hvdWxkIHNldCBzdGlja2luZXNzIHRvIGZhbHNlXG5cbiAgICBpc0VuZChhbmltYXRlVG8sIG1vZGUpIHx8IHNldFN0aWNreShmYWxzZSk7XG4gICAgc2V0QW5pbWF0ZVRvKG51bGwpO1xuICB9LCBbYW5pbWF0ZVRvUmVmLCBkZWJ1ZywgaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYsIG1vZGUsIHNldEFuaW1hdGVUbywgc2V0U3RpY2t5XSk7XG5cbiAgLy8gRnVuY3Rpb24gY29udGV4dFxuICBjb25zdCBzY3JvbGxUbyA9IHVzZUNhbGxiYWNrKFxuICAgIChuZXh0QW5pbWF0ZVRvLCB7IGJlaGF2aW9yIH0gPSB7fSkgPT4ge1xuICAgICAgY29uc3QgeyBjdXJyZW50OiB0YXJnZXQgfSA9IHRhcmdldFJlZjtcblxuICAgICAgaWYgKHR5cGVvZiBuZXh0QW5pbWF0ZVRvICE9PSAnbnVtYmVyJyAmJiBuZXh0QW5pbWF0ZVRvICE9PSAnMTAwJScpIHtcbiAgICAgICAgcmV0dXJuIGNvbnNvbGUud2FybigncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogQXJndW1lbnRzIHBhc3NlZCB0byBzY3JvbGxUbygpIG11c3QgYmUgZWl0aGVyIG51bWJlciBvciBcIjEwMCVcIi4nKTtcbiAgICAgIH1cblxuICAgICAgLy8gSWYgaXQgaXMgdHJ5aW5nIHRvIHNjcm9sbCB0byBhIHBvc2l0aW9uIHdoaWNoIGlzIG5vdCBcImF0RW5kXCIsIGl0IHNob3VsZCBzZXQgc3RpY2t5IHRvIGZhbHNlIGFmdGVyIHNjcm9sbCBlbmRlZC5cblxuICAgICAgZGVidWcoKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYCVjc2Nyb2xsVG8lYzogV2lsbCBzY3JvbGwgdG8gJWMke1xuICAgICAgICAgICAgdHlwZW9mIG5leHRBbmltYXRlVG8gPT09ICdudW1iZXInID8gbmV4dEFuaW1hdGVUbyArICdweCcgOiBuZXh0QW5pbWF0ZVRvLnJlcGxhY2UoLyUvZ3UsICclJScpXG4gICAgICAgICAgfSVjYCxcbiAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ2xpbWUnLCAnJyksXG4gICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKVxuICAgICAgICBdLFxuICAgICAgICB7XG4gICAgICAgICAgYmVoYXZpb3IsXG4gICAgICAgICAgbmV4dEFuaW1hdGVUbyxcbiAgICAgICAgICB0YXJnZXRcbiAgICAgICAgfVxuICAgICAgXSk7XG5cbiAgICAgIGlmIChiZWhhdmlvciA9PT0gJ2F1dG8nKSB7XG4gICAgICAgIC8vIFN0b3AgYW55IGV4aXN0aW5nIGFuaW1hdGlvblxuICAgICAgICBoYW5kbGVTcGluZVRvRW5kKCk7XG5cbiAgICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICAgIC8vIEp1bXAgdG8gdGhlIHNjcm9sbCBwb3NpdGlvblxuICAgICAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSBuZXh0QW5pbWF0ZVRvID09PSAnMTAwJScgPyB0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gdGFyZ2V0Lm9mZnNldEhlaWdodCA6IG5leHRBbmltYXRlVG87XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJlaGF2aW9yICE9PSAnc21vb3RoJyAmJlxuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1wiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICAgKTtcblxuICAgICAgICBzZXRBbmltYXRlVG8obmV4dEFuaW1hdGVUbyk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGhhbmRsaW5nIGEgY2FzZS4gV2hlbiBjYWxsaW5nIHNjcm9sbFRvKCcxMDAlJywgeyBiZWhhdmlvcjogJ2F1dG8nIH0pIG11bHRpcGxlIHRpbWVzLCBpdCB3b3VsZCBsb3NlIHN0aWNraW5lc3MuXG4gICAgICBpZiAoaXNFbmQobmV4dEFuaW1hdGVUbywgbW9kZSkpIHtcbiAgICAgICAgZGVidWcoKCkgPT4gW1xuICAgICAgICAgIFtcbiAgICAgICAgICAgIGAlY3Njcm9sbFRvJWM6IFNjcm9sbGluZyB0byBlbmQsIHdpbGwgc2V0IHN0aWNreSB0byAlY3RydWUlYy5gLFxuICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdsaW1lJywgJycpLFxuICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKVxuICAgICAgICAgIF0sXG4gICAgICAgICAgW3sgbW9kZSwgbmV4dEFuaW1hdGVUbyB9XVxuICAgICAgICBdKTtcblxuICAgICAgICBzZXRTdGlja3kodHJ1ZSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbZGVidWcsIGhhbmRsZVNwaW5lVG9FbmQsIG1vZGUsIHNldEFuaW1hdGVUbywgc2V0U3RpY2t5LCB0YXJnZXRSZWZdXG4gICk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9Cb3R0b20gPSB1c2VDYWxsYmFjayhcbiAgICAoeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGRlYnVnKCgpID0+IFsnJWNzY3JvbGxUb0JvdHRvbSVjOiBDYWxsZWQnLCAuLi5zdHlsZUNvbnNvbGUoJ3llbGxvdycsICcnKV0pO1xuXG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb0JvdHRvbVwiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICk7XG5cbiAgICAgIHNjcm9sbFRvKCcxMDAlJywgeyBiZWhhdmlvcjogYmVoYXZpb3IgfHwgJ3Ntb290aCcgfSk7XG4gICAgfSxcbiAgICBbZGVidWcsIHNjcm9sbFRvXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvVG9wID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBkZWJ1ZygoKSA9PiBbJyVjc2Nyb2xsVG9Ub3AlYzogQ2FsbGVkJywgLi4uc3R5bGVDb25zb2xlKCd5ZWxsb3cnLCAnJyldKTtcblxuICAgICAgYmVoYXZpb3IgIT09ICdzbW9vdGgnICYmXG4gICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAncmVhY3Qtc2Nyb2xsLXRvLWJvdHRvbTogUGxlYXNlIHNldCBcImJlaGF2aW9yXCIgd2hlbiBjYWxsaW5nIFwic2Nyb2xsVG9Ub3BcIi4gSW4gZnV0dXJlIHZlcnNpb25zLCB0aGUgZGVmYXVsdCBiZWhhdmlvciB3aWxsIGJlIGNoYW5nZWQgZnJvbSBzbW9vdGggc2Nyb2xsaW5nIHRvIGRpc2NyZXRlIHNjcm9sbGluZyB0byBhbGlnbiB3aXRoIEhUTUwgU3RhbmRhcmQuJ1xuICAgICAgICApO1xuXG4gICAgICBzY3JvbGxUbygwLCB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9KTtcbiAgICB9LFxuICAgIFtkZWJ1Zywgc2Nyb2xsVG9dXG4gICk7XG5cbiAgY29uc3Qgc2Nyb2xsVG9FbmQgPSB1c2VDYWxsYmFjayhcbiAgICAoeyBiZWhhdmlvciB9ID0ge30pID0+IHtcbiAgICAgIGRlYnVnKCgpID0+IFsnJWNzY3JvbGxUb0VuZCVjOiBDYWxsZWQnLCAuLi5zdHlsZUNvbnNvbGUoJ3llbGxvdycsICcnKV0pO1xuXG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb0VuZFwiLiBJbiBmdXR1cmUgdmVyc2lvbnMsIHRoZSBkZWZhdWx0IGJlaGF2aW9yIHdpbGwgYmUgY2hhbmdlZCBmcm9tIHNtb290aCBzY3JvbGxpbmcgdG8gZGlzY3JldGUgc2Nyb2xsaW5nIHRvIGFsaWduIHdpdGggSFRNTCBTdGFuZGFyZC4nXG4gICAgICAgICk7XG5cbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB7IGJlaGF2aW9yOiBiZWhhdmlvciB8fCAnc21vb3RoJyB9O1xuXG4gICAgICBtb2RlID09PSBNT0RFX1RPUCA/IHNjcm9sbFRvVG9wKG9wdGlvbnMpIDogc2Nyb2xsVG9Cb3R0b20ob3B0aW9ucyk7XG4gICAgfSxcbiAgICBbZGVidWcsIG1vZGUsIHNjcm9sbFRvQm90dG9tLCBzY3JvbGxUb1RvcF1cbiAgKTtcblxuICBjb25zdCBzY3JvbGxUb1N0YXJ0ID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgYmVoYXZpb3IgfSA9IHt9KSA9PiB7XG4gICAgICBkZWJ1ZygoKSA9PiBbJyVjc2Nyb2xsVG9TdGFydCVjOiBDYWxsZWQnLCAuLi5zdHlsZUNvbnNvbGUoJ3llbGxvdycsICcnKV0pO1xuXG4gICAgICBiZWhhdmlvciAhPT0gJ3Ntb290aCcgJiZcbiAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICdyZWFjdC1zY3JvbGwtdG8tYm90dG9tOiBQbGVhc2Ugc2V0IFwiYmVoYXZpb3JcIiB3aGVuIGNhbGxpbmcgXCJzY3JvbGxUb1N0YXJ0XCIuIEluIGZ1dHVyZSB2ZXJzaW9ucywgdGhlIGRlZmF1bHQgYmVoYXZpb3Igd2lsbCBiZSBjaGFuZ2VkIGZyb20gc21vb3RoIHNjcm9sbGluZyB0byBkaXNjcmV0ZSBzY3JvbGxpbmcgdG8gYWxpZ24gd2l0aCBIVE1MIFN0YW5kYXJkLidcbiAgICAgICAgKTtcblxuICAgICAgY29uc3Qgb3B0aW9ucyA9IHsgYmVoYXZpb3I6IGJlaGF2aW9yIHx8ICdzbW9vdGgnIH07XG5cbiAgICAgIG1vZGUgPT09IE1PREVfVE9QID8gc2Nyb2xsVG9Cb3R0b20ob3B0aW9ucykgOiBzY3JvbGxUb1RvcChvcHRpb25zKTtcbiAgICB9LFxuICAgIFtkZWJ1ZywgbW9kZSwgc2Nyb2xsVG9Cb3R0b20sIHNjcm9sbFRvVG9wXVxuICApO1xuXG4gIGNvbnN0IHNjcm9sbFRvU3RpY2t5ID0gdXNlQ2FsbGJhY2soKCkgPT4ge1xuICAgIGNvbnN0IHsgY3VycmVudDogdGFyZ2V0IH0gPSB0YXJnZXRSZWY7XG5cbiAgICBpZiAodGFyZ2V0KSB7XG4gICAgICBpZiAoaW5pdGlhbFNjcm9sbEJlaGF2aW9yUmVmLmN1cnJlbnQgPT09ICdhdXRvJykge1xuICAgICAgICBkZWJ1ZygoKSA9PiBbYCVjdGFyZ2V0IGNoYW5nZWQlYzogSW5pdGlhbCBzY3JvbGxgLCAuLi5zdHlsZUNvbnNvbGUoJ2JsdWUnKV0pO1xuXG4gICAgICAgIHRhcmdldC5zY3JvbGxUb3AgPSBtb2RlID09PSBNT0RFX1RPUCA/IDAgOiB0YXJnZXQuc2Nyb2xsSGVpZ2h0IC0gdGFyZ2V0Lm9mZnNldEhlaWdodDtcbiAgICAgICAgaW5pdGlhbFNjcm9sbEJlaGF2aW9yUmVmLmN1cnJlbnQgPSBmYWxzZTtcblxuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFRoaXMgaXMgdmVyeSBzaW1pbGFyIHRvIHNjcm9sbFRvRW5kKCkuXG4gICAgICAvLyBJbnN0ZWFkIG9mIHNjcm9sbGluZyB0byBlbmQsIGl0IHdpbGwgY2FsbCBwcm9wcy5zY3JvbGxlcigpIHRvIGRldGVybWluZXMgaG93IGZhciBpdCBzaG91bGQgc2Nyb2xsLlxuICAgICAgLy8gVGhpcyBmdW5jdGlvbiBjb3VsZCBiZSBjYWxsZWQgd2hpbGUgaXQgaXMgYXV0by1zY3JvbGxpbmcuXG5cbiAgICAgIGNvbnN0IHsgY3VycmVudDogYW5pbWF0ZUZyb20gfSA9IGFuaW1hdGVGcm9tUmVmO1xuICAgICAgY29uc3QgeyBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gPSB0YXJnZXQ7XG5cbiAgICAgIGNvbnN0IG1heFZhbHVlID0gbW9kZSA9PT0gTU9ERV9UT1AgPyAwIDogTWF0aC5tYXgoMCwgc2Nyb2xsSGVpZ2h0IC0gb2Zmc2V0SGVpZ2h0IC0gc2Nyb2xsVG9wKTtcbiAgICAgIGNvbnN0IG1pblZhbHVlID0gTWF0aC5tYXgoMCwgYW5pbWF0ZUZyb20gLSBzY3JvbGxUb3ApO1xuXG4gICAgICBjb25zdCByYXdOZXh0VmFsdWUgPSBzY3JvbGxlcih7IG1heFZhbHVlLCBtaW5WYWx1ZSwgb2Zmc2V0SGVpZ2h0LCBzY3JvbGxIZWlnaHQsIHNjcm9sbFRvcCB9KTtcblxuICAgICAgY29uc3QgbmV4dFZhbHVlID0gTWF0aC5tYXgoMCwgTWF0aC5taW4obWF4VmFsdWUsIHJhd05leHRWYWx1ZSkpO1xuXG4gICAgICBsZXQgbmV4dEFuaW1hdGVUbztcblxuICAgICAgaWYgKG1vZGUgPT09IE1PREVfVE9QIHx8IG5leHRWYWx1ZSAhPT0gbWF4VmFsdWUpIHtcbiAgICAgICAgbmV4dEFuaW1hdGVUbyA9IHNjcm9sbFRvcCArIG5leHRWYWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIFdoZW4gc2Nyb2xsaW5nIHRvIGJvdHRvbSwgd2Ugc2hvdWxkIHNjcm9sbCB0byBcIjEwMCVcIi5cbiAgICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB3ZSBzY3JvbGwgdG8gYW55IG51bWJlciwgaXQgd2lsbCBsb3NlIHN0aWNraW5lc3Mgd2hlbiBlbGVtZW50cyBhcmUgYWRkaW5nIHRvbyBmYXN0LlxuICAgICAgICAvLyBcIjEwMCVcIiBpcyBhIHNwZWNpYWwgYXJndW1lbnQgaW50ZW5kZWQgdG8gbWFrZSBzdXJlIHN0aWNraW5lc3MgaXMgbm90IGxvc3Qgd2hpbGUgbmV3IGVsZW1lbnRzIGFyZSBiZWluZyBhZGRlZC5cbiAgICAgICAgbmV4dEFuaW1hdGVUbyA9ICcxMDAlJztcbiAgICAgIH1cblxuICAgICAgZGVidWcoKCkgPT4gW1xuICAgICAgICBbXG4gICAgICAgICAgYCVjc2Nyb2xsVG9TdGlja3klYzogV2lsbCBhbmltYXRlIGZyb20gJWMke2FuaW1hdGVGcm9tfXB4JWMgdG8gJWMke1xuICAgICAgICAgICAgdHlwZW9mIG5leHRBbmltYXRlVG8gPT09ICdudW1iZXInID8gbmV4dEFuaW1hdGVUbyArICdweCcgOiBuZXh0QW5pbWF0ZVRvLnJlcGxhY2UoLyUvZ3UsICclJScpXG4gICAgICAgICAgfSVjICglYyR7KG5leHRBbmltYXRlVG8gPT09ICcxMDAlJyA/IG1heFZhbHVlIDogbmV4dEFuaW1hdGVUbykgKyBhbmltYXRlRnJvbX1weCVjKWAsXG4gICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdvcmFuZ2UnKSxcbiAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ3B1cnBsZScpLFxuICAgICAgICAgIC4uLnN0eWxlQ29uc29sZSgncHVycGxlJyksXG4gICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKVxuICAgICAgICBdLFxuICAgICAgICB7XG4gICAgICAgICAgYW5pbWF0ZUZyb20sXG4gICAgICAgICAgbWF4VmFsdWUsXG4gICAgICAgICAgbWluVmFsdWUsXG4gICAgICAgICAgbmV4dEFuaW1hdGVUbyxcbiAgICAgICAgICBuZXh0VmFsdWUsXG4gICAgICAgICAgb2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgIHJhd05leHRWYWx1ZSxcbiAgICAgICAgICBzY3JvbGxIZWlnaHQsXG4gICAgICAgICAgc2Nyb2xsVG9wXG4gICAgICAgIH1cbiAgICAgIF0pO1xuXG4gICAgICBzY3JvbGxUbyhuZXh0QW5pbWF0ZVRvLCB7IGJlaGF2aW9yOiAnc21vb3RoJyB9KTtcbiAgICB9XG4gIH0sIFthbmltYXRlRnJvbVJlZiwgZGVidWcsIG1vZGUsIHNjcm9sbGVyLCBzY3JvbGxUbywgdGFyZ2V0UmVmXSk7XG5cbiAgY29uc3QgaGFuZGxlU2Nyb2xsID0gdXNlQ2FsbGJhY2soXG4gICAgKHsgdGltZVN0YW1wTG93IH0pID0+IHtcbiAgICAgIGNvbnN0IHsgY3VycmVudDogYW5pbWF0ZVRvIH0gPSBhbmltYXRlVG9SZWY7XG4gICAgICBjb25zdCB7IGN1cnJlbnQ6IHRhcmdldCB9ID0gdGFyZ2V0UmVmO1xuXG4gICAgICBjb25zdCBhbmltYXRpbmcgPSBhbmltYXRlVG8gIT09IG51bGw7XG5cbiAgICAgIC8vIEN1cnJlbnRseSwgdGhlcmUgYXJlIG5vIHJlbGlhYmxlIHdheSB0byBjaGVjayBpZiB0aGUgXCJzY3JvbGxcIiBldmVudCBpcyB0cmlnZ2VyIGR1ZSB0b1xuICAgICAgLy8gdXNlciBnZXN0dXJlLCBwcm9ncmFtbWF0aWMgc2Nyb2xsaW5nLCBvciBDaHJvbWUtc3ludGhlc2l6ZWQgXCJzY3JvbGxcIiBldmVudCB0byBjb21wZW5zYXRlIHNpemUgY2hhbmdlLlxuICAgICAgLy8gVGh1cywgd2UgdXNlIG91ciBiZXN0LWVmZm9ydCB0byBndWVzcyBpZiBpdCBpcyB0cmlnZ2VyZWQgYnkgdXNlciBnZXN0dXJlLCBhbmQgZGlzYWJsZSBzdGlja3kgaWYgaXQgaXMgaGVhZGluZyB0b3dhcmRzIHRoZSBzdGFydCBkaXJlY3Rpb24uXG5cbiAgICAgIGlmICh0aW1lU3RhbXBMb3cgPD0gaWdub3JlU2Nyb2xsRXZlbnRCZWZvcmVSZWYuY3VycmVudCB8fCAhdGFyZ2V0KSB7XG4gICAgICAgIC8vIFNpbmNlIHdlIGRlYm91bmNlIFwic2Nyb2xsXCIgZXZlbnQsIHRoaXMgaGFuZGxlciBtaWdodCBiZSBjYWxsZWQgYWZ0ZXIgc3BpbmVUby5vbkVuZCAoYS5rLmEuIGFydGlmaWNpYWwgc2Nyb2xsaW5nKS5cbiAgICAgICAgLy8gV2Ugc2hvdWxkIGlnbm9yZSBkZWJvdW5jZWQgZXZlbnQgZmlyZWQgYWZ0ZXIgc2Nyb2xsRW5kLCBiZWNhdXNlIHdpdGhvdXQgc2tpcHBpbmcgdGhlbSwgdGhlIHVzZXJJbml0aWF0ZWRTY3JvbGwgY2FsY3VsYXRlZCBiZWxvdyB3aWxsIG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgICAgLy8gVGh1cywgb24gYSBmYXN0IG1hY2hpbmUsIGFkZGluZyBlbGVtZW50cyBzdXBlciBmYXN0IHdpbGwgbG9zZSB0aGUgXCJzdGlja2luZXNzXCIuXG5cbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICBjb25zdCB7IGF0Qm90dG9tLCBhdEVuZCwgYXRTdGFydCwgYXRUb3AgfSA9IGNvbXB1dGVWaWV3U3RhdGUoeyBtb2RlLCB0YXJnZXQgfSk7XG5cbiAgICAgIHNldEF0Qm90dG9tKGF0Qm90dG9tKTtcbiAgICAgIHNldEF0RW5kKGF0RW5kKTtcbiAgICAgIHNldEF0U3RhcnQoYXRTdGFydCk7XG4gICAgICBzZXRBdFRvcChhdFRvcCk7XG5cbiAgICAgIC8vIENocm9tZSB3aWxsIGVtaXQgXCJzeW50aGV0aWNcIiBzY3JvbGwgZXZlbnQgaWYgdGhlIGNvbnRhaW5lciBpcyByZXNpemVkIG9yIGFuIGVsZW1lbnQgaXMgYWRkZWRcbiAgICAgIC8vIFdlIG5lZWQgdG8gaWdub3JlIHRoZXNlIFwic3ludGhldGljXCIgZXZlbnRzXG4gICAgICAvLyBSZXBybzogSW4gcGxheWdyb3VuZCwgcHJlc3MgNC0xLTUtMS0xIChzbWFsbCwgYWRkIG9uZSwgbm9ybWFsLCBhZGQgb25lLCBhZGQgb25lKVxuICAgICAgLy8gICAgICAgIE5vbWF0dGVyIGhvdyBmYXN0IG9yIHNsb3cgdGhlIHNlcXVlbmNlIGlzIGJlaW5nIHByZXNzZWQsIGl0IHNob3VsZCBzdGlsbCBzdGljayB0byB0aGUgYm90dG9tXG4gICAgICBjb25zdCB7IG9mZnNldEhlaWdodDogbmV4dE9mZnNldEhlaWdodCwgc2Nyb2xsSGVpZ2h0OiBuZXh0U2Nyb2xsSGVpZ2h0IH0gPSB0YXJnZXQ7XG4gICAgICBjb25zdCB7IGN1cnJlbnQ6IG9mZnNldEhlaWdodCB9ID0gb2Zmc2V0SGVpZ2h0UmVmO1xuICAgICAgY29uc3QgeyBjdXJyZW50OiBzY3JvbGxIZWlnaHQgfSA9IHNjcm9sbEhlaWdodFJlZjtcbiAgICAgIGNvbnN0IG9mZnNldEhlaWdodENoYW5nZWQgPSBuZXh0T2Zmc2V0SGVpZ2h0ICE9PSBvZmZzZXRIZWlnaHQ7XG4gICAgICBjb25zdCBzY3JvbGxIZWlnaHRDaGFuZ2VkID0gbmV4dFNjcm9sbEhlaWdodCAhPT0gc2Nyb2xsSGVpZ2h0O1xuXG4gICAgICBpZiAob2Zmc2V0SGVpZ2h0Q2hhbmdlZCkge1xuICAgICAgICBvZmZzZXRIZWlnaHRSZWYuY3VycmVudCA9IG5leHRPZmZzZXRIZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIGlmIChzY3JvbGxIZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgIHNjcm9sbEhlaWdodFJlZi5jdXJyZW50ID0gbmV4dFNjcm9sbEhlaWdodDtcbiAgICAgIH1cblxuICAgICAgLy8gU3RpY2t5IG1lYW5zOlxuICAgICAgLy8gLSBJZiBpdCBpcyBzY3JvbGxlZCBwcm9ncmFtYXRpY2FsbHksIHdlIGFyZSBzdGlsbCBpbiBzdGlja3kgbW9kZVxuICAgICAgLy8gLSBJZiBpdCBpcyBzY3JvbGxlZCBieSB0aGUgdXNlciwgdGhlbiBzdGlja3kgbWVhbnMgaWYgd2UgYXJlIGF0IHRoZSBlbmRcblxuICAgICAgLy8gT25seSB1cGRhdGUgc3RpY2tpbmVzcyBpZiB0aGUgc2Nyb2xsIGV2ZW50IGlzIG5vdCBkdWUgdG8gc3ludGhldGljIHNjcm9sbCBkb25lIGJ5IENocm9tZVxuICAgICAgaWYgKCFvZmZzZXRIZWlnaHRDaGFuZ2VkICYmICFzY3JvbGxIZWlnaHRDaGFuZ2VkKSB7XG4gICAgICAgIC8vIFdlIGFyZSBzdGlja3kgaWYgd2UgYXJlIGFuaW1hdGluZyB0byB0aGUgZW5kLCBvciB3ZSBhcmUgYWxyZWFkeSBhdCB0aGUgZW5kLlxuICAgICAgICAvLyBXZSBjYW4gYmUgXCJhbmltYXRpbmcgYnV0IG5vdCBzdGlja3lcIiBieSBjYWxsaW5nIFwic2Nyb2xsVG8oMTAwKVwiIHdoZXJlIHRoZSBjb250YWluZXIgc2Nyb2xsSGVpZ2h0IGlzIDIwMHB4LlxuICAgICAgICBjb25zdCBuZXh0U3RpY2t5ID0gKGFuaW1hdGluZyAmJiBpc0VuZChhbmltYXRlVG8sIG1vZGUpKSB8fCBhdEVuZDtcblxuICAgICAgICBpZiAoc3RpY2t5UmVmLmN1cnJlbnQgIT09IG5leHRTdGlja3kpIHtcbiAgICAgICAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAgICAgICBbXG4gICAgICAgICAgICAgIGAlY29uU2Nyb2xsJWM6ICVjc2V0U3RpY2t5JWMoJWMke25leHRTdGlja3l9JWMpYCxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdyZWQnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdyZWQnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKVxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgYChhbmltYXRpbmcgPSAlYyR7YW5pbWF0aW5nfSVjICYmIGlzRW5kID0gJWMke2lzRW5kKGFuaW1hdGVUbywgbW9kZSl9JWMpIHx8IGF0RW5kID0gJWMke2F0RW5kfSVjYCxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdwdXJwbGUnKSxcbiAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGFuaW1hdGluZyxcbiAgICAgICAgICAgICAgICBhbmltYXRlVG8sXG4gICAgICAgICAgICAgICAgYXRFbmQsXG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICBvZmZzZXRIZWlnaHQ6IHRhcmdldC5vZmZzZXRIZWlnaHQsXG4gICAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0OiB0YXJnZXQuc2Nyb2xsSGVpZ2h0LFxuICAgICAgICAgICAgICAgIHN0aWNreSxcbiAgICAgICAgICAgICAgICBuZXh0U3RpY2t5XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIHNldFN0aWNreShuZXh0U3RpY2t5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzdGlja3lSZWYuY3VycmVudCkge1xuICAgICAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAgICAgW1xuICAgICAgICAgICAgYCVjb25TY3JvbGwlYzogU2l6ZSBjaGFuZ2VkIHdoaWxlIHN0aWNreSwgY2FsbGluZyAlY3Njcm9sbFRvU3RpY2t5KCklY2AsXG4gICAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ3JlZCcpLFxuICAgICAgICAgICAgLi4uc3R5bGVDb25zb2xlKCdvcmFuZ2UnKSxcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0Q2hhbmdlZCxcbiAgICAgICAgICAgICAgc2Nyb2xsSGVpZ2h0Q2hhbmdlZFxuICAgICAgICAgICAgfVxuICAgICAgICAgIF0sXG4gICAgICAgICAge1xuICAgICAgICAgICAgbmV4dE9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIHByZXZPZmZzZXRIZWlnaHQ6IG9mZnNldEhlaWdodCxcbiAgICAgICAgICAgIG5leHRTY3JvbGxIZWlnaHQsXG4gICAgICAgICAgICBwcmV2U2Nyb2xsSGVpZ2h0OiBzY3JvbGxIZWlnaHRcbiAgICAgICAgICB9XG4gICAgICAgIF0pO1xuXG4gICAgICAgIHNjcm9sbFRvU3RpY2t5KCk7XG4gICAgICB9XG5cbiAgICAgIGNvbnN0IHsgc2Nyb2xsVG9wOiBhY3R1YWxTY3JvbGxUb3AgfSA9IHRhcmdldDtcblxuICAgICAgc2Nyb2xsUG9zaXRpb25PYnNlcnZlcnNSZWYuY3VycmVudC5mb3JFYWNoKG9ic2VydmVyID0+IG9ic2VydmVyKHsgc2Nyb2xsVG9wOiBhY3R1YWxTY3JvbGxUb3AgfSkpO1xuICAgIH0sXG4gICAgW1xuICAgICAgYW5pbWF0ZVRvUmVmLFxuICAgICAgZGVidWcsXG4gICAgICBpZ25vcmVTY3JvbGxFdmVudEJlZm9yZVJlZixcbiAgICAgIG1vZGUsXG4gICAgICBvZmZzZXRIZWlnaHRSZWYsXG4gICAgICBzY3JvbGxIZWlnaHRSZWYsXG4gICAgICBzY3JvbGxQb3NpdGlvbk9ic2VydmVyc1JlZixcbiAgICAgIHNjcm9sbFRvU3RpY2t5LFxuICAgICAgc2V0QXRCb3R0b20sXG4gICAgICBzZXRBdEVuZCxcbiAgICAgIHNldEF0U3RhcnQsXG4gICAgICBzZXRBdFRvcCxcbiAgICAgIHNldFN0aWNreSxcbiAgICAgIHN0aWNreVJlZixcbiAgICAgIHRhcmdldFJlZlxuICAgIF1cbiAgKTtcblxuICB1c2VFZmZlY3QoKCkgPT4ge1xuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGxldCBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG5cbiAgICAgIGNvbnN0IHRpbWVvdXQgPSBzZXRJbW1lZGlhdGVJbnRlcnZhbCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgY3VycmVudDogdGFyZ2V0IH0gPSB0YXJnZXRSZWY7XG4gICAgICAgIGNvbnN0IGFuaW1hdGluZyA9IGFuaW1hdGVUb1JlZi5jdXJyZW50ICE9PSBudWxsO1xuXG4gICAgICAgIGlmIChzdGlja3lSZWYuY3VycmVudCkge1xuICAgICAgICAgIGlmICghY29tcHV0ZVZpZXdTdGF0ZSh7IG1vZGUsIHRhcmdldCB9KS5hdEVuZCkge1xuICAgICAgICAgICAgaWYgKCFzdGlja3lCdXROb3RBdEVuZFNpbmNlKSB7XG4gICAgICAgICAgICAgIHN0aWNreUJ1dE5vdEF0RW5kU2luY2UgPSBEYXRlLm5vdygpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChEYXRlLm5vdygpIC0gc3RpY2t5QnV0Tm90QXRFbmRTaW5jZSA+IFNDUk9MTF9ERUNJU0lPTl9EVVJBVElPTikge1xuICAgICAgICAgICAgICAvLyBRdWlya3M6IEluIEZpcmVmb3gsIGFmdGVyIHVzZXIgc2Nyb2xsIGRvd24sIEZpcmVmb3ggZG8gdHdvIHRoaW5nczpcbiAgICAgICAgICAgICAgLy8gICAgICAgICAxLiBTZXQgdG8gYSBuZXcgXCJzY3JvbGxUb3BcIlxuICAgICAgICAgICAgICAvLyAgICAgICAgIDIuIEZpcmUgXCJzY3JvbGxcIiBldmVudFxuICAgICAgICAgICAgICAvLyAgICAgICAgIEZvciB3aGF0IHdlIG9ic2VydmVkLCAjMSBpcyBmaXJlZCBhYm91dCAyMG1zIGJlZm9yZSAjMi4gVGhlcmUgaXMgYSBjaGFuY2UgdGhhdCB0aGlzIHN0aWNreUNoZWNrVGltZW91dCBpcyBiZWluZyBzY2hlZHVsZWQgYmV0d2VlbiAxIGFuZCAyLlxuICAgICAgICAgICAgICAvLyAgICAgICAgIFRoYXQgbWVhbnMsIGlmIHdlIGp1c3QgbG9vayBhdCAjMSB0byBkZWNpZGUgaWYgd2Ugc2hvdWxkIHNjcm9sbCwgd2Ugd2lsbCBhbHdheXMgc2Nyb2xsLCBpbiBvcHBvc2UgdG8gdGhlIHVzZXIncyBpbnRlbnRpb24uXG4gICAgICAgICAgICAgIC8vIFJlcHJvOiBPcGVuIEZpcmVmb3gsIHNldCBjaGVja0ludGVydmFsIHRvIGEgbG93ZXIgbnVtYmVyLCBhbmQgdHJ5IHRvIHNjcm9sbCBieSBkcmFnZ2luZyB0aGUgc2Nyb2xsIGhhbmRsZXIuIEl0IHdpbGwganVtcCBiYWNrLlxuXG4gICAgICAgICAgICAgIC8vIFRoZSBcImFuaW1hdGluZ1wiIGNoZWNrIHdpbGwgbWFrZSBzdXJlIHN0aWNraW5lc3MgaXMgbm90IGxvc3Qgd2hlbiBlbGVtZW50cyBhcmUgYWRkaW5nIGF0IGEgdmVyeSBmYXN0IHBhY2UuXG4gICAgICAgICAgICAgIGlmICghYW5pbWF0aW5nKSB7XG4gICAgICAgICAgICAgICAgYW5pbWF0ZUZyb21SZWYuY3VycmVudCA9IHRhcmdldC5zY3JvbGxUb3A7XG5cbiAgICAgICAgICAgICAgICBkZWJ1ZygoKSA9PiBbXG4gICAgICAgICAgICAgICAgICBgJWNJbnRlcnZhbCBjaGVjayVjOiBTaG91bGQgc3RpY2t5IGJ1dCBub3QgYXQgZW5kLCBjYWxsaW5nICVjc2Nyb2xsVG9TdGlja3koKSVjIHRvIHNjcm9sbGAsXG4gICAgICAgICAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ25hdnknKSxcbiAgICAgICAgICAgICAgICAgIC4uLnN0eWxlQ29uc29sZSgnb3JhbmdlJylcbiAgICAgICAgICAgICAgICBdKTtcblxuICAgICAgICAgICAgICAgIHNjcm9sbFRvU3RpY2t5KCk7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBzdGlja3lCdXROb3RBdEVuZFNpbmNlID0gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0aWNreUJ1dE5vdEF0RW5kU2luY2UgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAodGFyZ2V0LnNjcm9sbEhlaWdodCA8PSB0YXJnZXQub2Zmc2V0SGVpZ2h0ICYmICFzdGlja3lSZWYuY3VycmVudCkge1xuICAgICAgICAgIC8vIFdoZW4gdGhlIGNvbnRhaW5lciBpcyBlbXB0aWVkLCB3ZSB3aWxsIHNldCBzdGlja3kgYmFjayB0byB0cnVlLlxuXG4gICAgICAgICAgZGVidWcoKCkgPT4gW1xuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICBgJWNJbnRlcnZhbCBjaGVjayVjOiBDb250YWluZXIgaXMgZW1wdGllZCwgc2V0dGluZyBzdGlja3kgYmFjayB0byAlY3RydWUlY2AsXG4gICAgICAgICAgICAgIC4uLnN0eWxlQ29uc29sZSgnbmF2eScpLFxuICAgICAgICAgICAgICAuLi5zdHlsZUNvbnNvbGUoJ3B1cnBsZScpXG4gICAgICAgICAgICBdLFxuICAgICAgICAgICAgW1xuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgb2Zmc2V0SGVpZ2h0OiB0YXJnZXQub2Zmc2V0SGVpZ2h0LFxuICAgICAgICAgICAgICAgIHNjcm9sbEhlaWdodDogdGFyZ2V0LnNjcm9sbEhlaWdodCxcbiAgICAgICAgICAgICAgICBzdGlja3k6IHN0aWNreVJlZi5jdXJyZW50XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF1cbiAgICAgICAgICBdKTtcblxuICAgICAgICAgIHNldFN0aWNreSh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgfSwgTWF0aC5tYXgoTUlOX0NIRUNLX0lOVEVSVkFMLCBjaGVja0ludGVydmFsKSB8fCBNSU5fQ0hFQ0tfSU5URVJWQUwpO1xuXG4gICAgICByZXR1cm4gKCkgPT4gY2xlYXJJbnRlcnZhbCh0aW1lb3V0KTtcbiAgICB9XG4gIH0sIFthbmltYXRlVG9SZWYsIGNoZWNrSW50ZXJ2YWwsIGRlYnVnLCBtb2RlLCBzY3JvbGxUb1N0aWNreSwgc2V0U3RpY2t5LCBzdGlja3lSZWYsIHRhcmdldCwgdGFyZ2V0UmVmXSk7XG5cbiAgY29uc3Qgc3R5bGVUb0NsYXNzTmFtZSA9IHVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IGVtb3Rpb24gPVxuICAgICAgZW1vdGlvblBvb2xbbm9uY2VdIHx8XG4gICAgICAoZW1vdGlvblBvb2xbbm9uY2VdID0gY3JlYXRlRW1vdGlvbih7IGtleTogJ3JlYWN0LXNjcm9sbC10by1ib3R0b20tLWNzcy0nICsgY3JlYXRlQ1NTS2V5KCksIG5vbmNlIH0pKTtcblxuICAgIHJldHVybiBzdHlsZSA9PiBlbW90aW9uLmNzcyhzdHlsZSkgKyAnJztcbiAgfSwgW25vbmNlXSk7XG5cbiAgY29uc3QgaW50ZXJuYWxDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgb2JzZXJ2ZVNjcm9sbFBvc2l0aW9uLFxuICAgICAgc2V0VGFyZ2V0LFxuICAgICAgc3R5bGVUb0NsYXNzTmFtZVxuICAgIH0pLFxuICAgIFtvYnNlcnZlU2Nyb2xsUG9zaXRpb24sIHNldFRhcmdldCwgc3R5bGVUb0NsYXNzTmFtZV1cbiAgKTtcblxuICBjb25zdCBzdGF0ZTFDb250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgYXRCb3R0b20sXG4gICAgICBhdEVuZCxcbiAgICAgIGF0U3RhcnQsXG4gICAgICBhdFRvcCxcbiAgICAgIG1vZGVcbiAgICB9KSxcbiAgICBbYXRCb3R0b20sIGF0RW5kLCBhdFN0YXJ0LCBhdFRvcCwgbW9kZV1cbiAgKTtcblxuICBjb25zdCBzdGF0ZTJDb250ZXh0ID0gdXNlTWVtbygoKSA9PiB7XG4gICAgY29uc3QgYW5pbWF0aW5nID0gYW5pbWF0ZVRvICE9PSBudWxsO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgIGFuaW1hdGluZyxcbiAgICAgIGFuaW1hdGluZ1RvRW5kOiBhbmltYXRpbmcgJiYgaXNFbmQoYW5pbWF0ZVRvLCBtb2RlKSxcbiAgICAgIHN0aWNreVxuICAgIH07XG4gIH0sIFthbmltYXRlVG8sIGRlYnVnLCBtb2RlLCBzdGlja3ldKTtcblxuICBjb25zdCBjb21iaW5lZFN0YXRlQ29udGV4dCA9IHVzZU1lbW8oXG4gICAgKCkgPT4gKHtcbiAgICAgIC4uLnN0YXRlMUNvbnRleHQsXG4gICAgICAuLi5zdGF0ZTJDb250ZXh0XG4gICAgfSksXG4gICAgW3N0YXRlMUNvbnRleHQsIHN0YXRlMkNvbnRleHRdXG4gICk7XG5cbiAgY29uc3QgZnVuY3Rpb25Db250ZXh0ID0gdXNlTWVtbyhcbiAgICAoKSA9PiAoe1xuICAgICAgc2Nyb2xsVG8sXG4gICAgICBzY3JvbGxUb0JvdHRvbSxcbiAgICAgIHNjcm9sbFRvRW5kLFxuICAgICAgc2Nyb2xsVG9TdGFydCxcbiAgICAgIHNjcm9sbFRvVG9wXG4gICAgfSksXG4gICAgW3Njcm9sbFRvLCBzY3JvbGxUb0JvdHRvbSwgc2Nyb2xsVG9FbmQsIHNjcm9sbFRvU3RhcnQsIHNjcm9sbFRvVG9wXVxuICApO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgLy8gV2UgbmVlZCB0byB1cGRhdGUgdGhlIFwic2Nyb2xsSGVpZ2h0XCIgdmFsdWUgdG8gbGF0ZXN0IHdoZW4gdGhlIHVzZXIgZG8gYSBmb2N1cyBpbnNpZGUgdGhlIGJveC5cbiAgICAvL1xuICAgIC8vIFRoaXMgaXMgYmVjYXVzZTpcbiAgICAvLyAtIEluIG91ciBjb2RlIHRoYXQgbWl0aWdhdGUgQ2hyb21lIHN5bnRoZXRpYyBzY3JvbGxpbmcsIHRoYXQgY29kZSB3aWxsIGxvb2sgYXQgd2hldGhlciBcInNjcm9sbEhlaWdodFwiIHZhbHVlIGlzIGxhdGVzdCBvciBub3QuXG4gICAgLy8gLSBUaGF0IGNvZGUgb25seSBydW4gb24gXCJzY3JvbGxcIiBldmVudC5cbiAgICAvLyAtIFRoYXQgbWVhbnMsIG9uIGV2ZXJ5IFwic2Nyb2xsXCIgZXZlbnQsIGlmIHRoZSBcInNjcm9sbEhlaWdodFwiIHZhbHVlIGlzIG5vdCBsYXRlc3QsIHdlIHdpbGwgc2tpcCBtb2RpZnlpbmcgdGhlIHN0aWNraW5lc3MuXG4gICAgLy8gLSBUaGF0IG1lYW5zLCBpZiB0aGUgdXNlciBcImZvY3VzXCIgdG8gYW4gZWxlbWVudCB0aGF0IGNhdXNlIHRoZSBzY3JvbGwgdmlldyB0byBzY3JvbGwgdG8gdGhlIGJvdHRvbSwgdGhlIHVzZXIgYWdlbnQgd2lsbCBmaXJlIFwic2Nyb2xsXCIgZXZlbnQuXG4gICAgLy8gICBTaW5jZSB0aGUgXCJzY3JvbGxIZWlnaHRcIiBpcyBub3QgbGF0ZXN0IHZhbHVlLCB0aGlzIFwic2Nyb2xsXCIgZXZlbnQgd2lsbCBiZSBpZ25vcmVkIGFuZCBzdGlja2luZXNzIHdpbGwgbm90IGJlIG1vZGlmaWVkLlxuICAgIC8vIC0gVGhhdCBtZWFucywgaWYgdGhlIHVzZXIgXCJmb2N1c1wiIHRvIGEgbmV3bHkgYWRkZWQgZWxlbWVudCB0aGF0IGlzIGF0IHRoZSBlbmQgb2YgdGhlIHNjcm9sbCB2aWV3LCB0aGUgXCJzY3JvbGwgdG8gYm90dG9tXCIgYnV0dG9uIHdpbGwgY29udGludWUgdG8gc2hvdy5cbiAgICAvL1xuICAgIC8vIFJlcHJvIGluIENocm9tZTpcbiAgICAvLyAxLiBGaWxsIHVwIGEgc2Nyb2xsIHZpZXdcbiAgICAvLyAyLiBTY3JvbGwgdXAsIHRoZSBcInNjcm9sbCB0byBib3R0b21cIiBidXR0b24gc2hvdWxkIHNob3cgdXBcbiAgICAvLyAzLiBDbGljayBcIkFkZCBhIGJ1dHRvblwiXG4gICAgLy8gNC4gQ2xpY2sgb24gdGhlIHNjcm9sbCB2aWV3ICh0byBwc2V1ZG8tZm9jdXMgb24gaXQpXG4gICAgLy8gNS4gUHJlc3MgVEFCLCB0aGUgc2Nyb2xsIHZpZXcgd2lsbCBiZSBhdCB0aGUgYm90dG9tXG4gICAgLy9cbiAgICAvLyBFeHBlY3Q6XG4gICAgLy8gLSBUaGUgXCJzY3JvbGwgdG8gYm90dG9tXCIgYnV0dG9uIHNob3VsZCBiZSBnb25lLlxuICAgIGlmICh0YXJnZXQpIHtcbiAgICAgIGNvbnN0IGhhbmRsZUZvY3VzID0gKCkgPT4ge1xuICAgICAgICBzY3JvbGxIZWlnaHRSZWYuY3VycmVudCA9IHRhcmdldC5zY3JvbGxIZWlnaHQ7XG4gICAgICB9O1xuXG4gICAgICB0YXJnZXQuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXMnLCBoYW5kbGVGb2N1cywgeyBjYXB0dXJlOiB0cnVlLCBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gICAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2ZvY3VzJywgaGFuZGxlRm9jdXMpO1xuICAgIH1cbiAgfSwgW3RhcmdldF0pO1xuXG4gIGRlYnVnKCgpID0+IFtcbiAgICBbYCVjUmVuZGVyJWM6IFJlbmRlcmAsIC4uLnN0eWxlQ29uc29sZSgnY3lhbicsICcnKV0sXG4gICAge1xuICAgICAgYW5pbWF0ZVRvLFxuICAgICAgYW5pbWF0aW5nOiBhbmltYXRlVG8gIT09IG51bGwsXG4gICAgICBzdGlja3ksXG4gICAgICB0YXJnZXRcbiAgICB9XG4gIF0pO1xuXG4gIHJldHVybiAoXG4gICAgPEludGVybmFsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17aW50ZXJuYWxDb250ZXh0fT5cbiAgICAgIDxGdW5jdGlvbkNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2Z1bmN0aW9uQ29udGV4dH0+XG4gICAgICAgIDxTdGF0ZUNvbnRleHQuUHJvdmlkZXIgdmFsdWU9e2NvbWJpbmVkU3RhdGVDb250ZXh0fT5cbiAgICAgICAgICA8U3RhdGUxQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGUxQ29udGV4dH0+XG4gICAgICAgICAgICA8U3RhdGUyQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17c3RhdGUyQ29udGV4dH0+XG4gICAgICAgICAgICAgIHtjaGlsZHJlbn1cbiAgICAgICAgICAgICAge3RhcmdldCAmJiA8RXZlbnRTcHkgZGVib3VuY2U9e2RlYm91bmNlfSBuYW1lPVwic2Nyb2xsXCIgb25FdmVudD17aGFuZGxlU2Nyb2xsfSB0YXJnZXQ9e3RhcmdldH0gLz59XG4gICAgICAgICAgICAgIHt0YXJnZXQgJiYgYW5pbWF0ZVRvICE9PSBudWxsICYmIChcbiAgICAgICAgICAgICAgICA8U3BpbmVUbyBuYW1lPVwic2Nyb2xsVG9wXCIgb25FbmQ9e2hhbmRsZVNwaW5lVG9FbmR9IHRhcmdldD17dGFyZ2V0fSB2YWx1ZT17YW5pbWF0ZVRvfSAvPlxuICAgICAgICAgICAgICApfVxuICAgICAgICAgICAgPC9TdGF0ZTJDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICAgIDwvU3RhdGUxQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgICAgPC9TdGF0ZUNvbnRleHQuUHJvdmlkZXI+XG4gICAgICA8L0Z1bmN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICA8L0ludGVybmFsQ29udGV4dC5Qcm92aWRlcj5cbiAgKTtcbn07XG5cbkNvbXBvc2VyLmRlZmF1bHRQcm9wcyA9IHtcbiAgY2hlY2tJbnRlcnZhbDogMTAwLFxuICBjaGlsZHJlbjogdW5kZWZpbmVkLFxuICBkZWJvdW5jZTogMTcsXG4gIGRlYnVnOiB1bmRlZmluZWQsXG4gIGluaXRpYWxTY3JvbGxCZWhhdmlvcjogJ3Ntb290aCcsXG4gIG1vZGU6IHVuZGVmaW5lZCxcbiAgbm9uY2U6IHVuZGVmaW5lZCxcbiAgc2Nyb2xsZXI6IERFRkFVTFRfU0NST0xMRVJcbn07XG5cbkNvbXBvc2VyLnByb3BUeXBlcyA9IHtcbiAgY2hlY2tJbnRlcnZhbDogUHJvcFR5cGVzLm51bWJlcixcbiAgY2hpbGRyZW46IFByb3BUeXBlcy5hbnksXG4gIGRlYm91bmNlOiBQcm9wVHlwZXMubnVtYmVyLFxuICBkZWJ1ZzogUHJvcFR5cGVzLmJvb2wsXG4gIGluaXRpYWxTY3JvbGxCZWhhdmlvcjogUHJvcFR5cGVzLm9uZU9mKFsnYXV0bycsICdzbW9vdGgnXSksXG4gIG1vZGU6IFByb3BUeXBlcy5vbmVPZihbJ2JvdHRvbScsICd0b3AnXSksXG4gIG5vbmNlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICBzY3JvbGxlcjogUHJvcFR5cGVzLmZ1bmNcbn07XG5cbmV4cG9ydCBkZWZhdWx0IENvbXBvc2VyO1xuIl19